import './object-assign-polyfill'

import plurals from './plurals'
import { install, Vue } from './install'

const EVALUATION_RE = /[[\].]{1,2}/g

/* Interpolation RegExp.
 *
 * Because interpolation inside attributes are deprecated in Vue 2 we have to
 * use another set of delimiters to be able to use `translate-plural` etc.
 * We use %{ } delimiters.
 *
 * /
 *   %\{                => Starting delimiter: `%{`
 *     (                => Start capture
 *       (?:.|\n)       => Non-capturing group: any character or newline
 *       +?             => One or more times (ungreedy)
 *     )                => End capture
 *   \}                 => Ending delimiter: `}`
 * /g                   => Global: don't return after first match
 */
const INTERPOLATION_RE = /%\{((?:.|\n)+?)\}/g

const MUSTACHE_SYNTAX_RE = /\{\{((?:.|\n)+?)\}\}/g
export default class VueGettext {
  constructor (options = {}) {
    const defaultConfig = {
      availableLanguages: { en_US: 'English (United States)' },
      defaultLanguage: 'en_US',
      // languageVmMixin: {},
      silent: Vue && Vue.config && Vue.config.silent,
      translations: {},
    }

    Object.keys(options).forEach(key => {
      if (Object.keys(defaultConfig).indexOf(key) === -1 && key !== 'language') {
        throw new Error(`${key} is an invalid option for the translate plugin.`)
      }
    })

    if (!options.translations) {
      throw new Error('No translations available.')
    }

    const finalOptions = Object.assign({},
      defaultConfig,
      options)

    const available = finalOptions.availableLanguages || defaultConfig.availableLanguages
    const language = finalOptions.language || finalOptions.defaultLanguage || defaultConfig.defaultLanguage
    const translations = finalOptions.translations || {}
    const activeTranslations = translations[language] || {}
    const silent = finalOptions.silent

    this._initVM({
      available,
      language,
      silent,
      translations,
      activeTranslations,
    })
  }

  _initVM (data) {
    this._vm = new Vue({ data })
  }

  get vm () { return this._vm }

  get available () { return this._vm.available }
  get language () { return this._vm.language }
  set language (value) {
    if (typeof this._vm.available[value] === 'undefined') {
      return
    }
    if (typeof this._vm.translations[value] === 'undefined') {
      return
    }
    this._vm.language = value
    this._vm.activeTranslations = this._vm.translations[value] || {}
  }
  get activeTranslations () { return this._vm.activeTranslations }
  get translations () { return this._vm.translations }

  /**
  * Get the translated string from the translation.json file generated by easygettext.
  *
  * @param {String} msgid - The translation key
  * @param {Number} n - The number to switch between singular and plural
  * @param {String} context - The translation key context
  * @param {String} defaultPlural - The default plural value (optional)
  * @param {String} language - The language ID (e.g. 'fr_FR' or 'en_US')
  *
  * @return {String} The translated string
  */
  getTranslation (msgid, n = 1, context = null, defaultPlural = null, language = this.language) {
    if (!msgid) {
      return ''  // Allow empty strings.
    }

    // `easygettext`'s `gettext-compile` generates a JSON version of a .po file based on its `Language` field.
    // But in this field, `ll_CC` combinations denoting a languageâ€™s main dialect are abbreviated as `ll`,
    // for example `de` is equivalent to `de_DE` (German as spoken in Germany).
    // See the `Language` section in https://www.gnu.org/software/gettext/manual/html_node/Header-Entry.html
    // So try `ll_CC` first, or the `ll` abbreviation which can be three-letter sometimes:
    // https://www.gnu.org/software/gettext/manual/html_node/Language-Codes.html#Language-Codes
    let translations = this.activeTranslations

    if (!translations) {
      if (!this._vm.silent) {
        console.warn(`No translations found for ${language}`)
      }
      // Returns the untranslated string, singular or plural.
      return defaultPlural && plurals.getTranslationIndex(language, n) > 0 ? defaultPlural : msgid
    }

    let translated = translations[msgid]

    // Sometimes msgid may not have the same number of spaces than its key. This could happen e.g. when using
    // new lines. See comments in the `created` hook of `component.js` and issue #15 for more information.
    if (!translated && /\s{2,}/g.test(msgid)) {
      Object.keys(translations).some(key => {
        if (key.replace(/\s{2,}/g, ' ') === msgid.trim().replace(/\s{2,}/g, ' ')) {
          translated = translations[key]
          return translated
        }
      })
    }

    if (!translated) {
      if (!this._vm.silent) {
        console.warn(`Untranslated ${language} key found:\n${msgid}`)
      }
      // Returns the untranslated string, singular or plural.
      return defaultPlural && plurals.getTranslationIndex(language, n) > 0 ? defaultPlural : msgid
    }

    if (context) {
      translated = translated[context]
    }

    if (typeof translated === 'string') {
      translated = [null, translated]
    }

    // Avoid a crash when a msgid exists with and without a context, see #32.
    if (!(translated instanceof Array) && translated.hasOwnProperty('')) {
      // As things currently stand, the void key means a void context for easygettext.
      translated = [translated['']]
    }

    const portion = translated[plurals.getTranslationIndex(language, n) + 1]


    if (typeof portion === 'string') {
      return portion
    }

    return portion[0]
  }

  /**
  * Returns a string of the translation of the message.
  * Also makes the string discoverable by xgettext.
  *
  * @param {String} msgid - The translation key
  *
  * @return {String} The translated string
  */
  gettext (msgid) {
    return this.getTranslation(msgid)
  }

  /**
  * Returns a string of the translation for the given context.
  * Also makes the string discoverable by xgettext.
  *
  * @param {String} context - The context of the string to translate
  * @param {String} msgid - The translation key
  *
  * @return {String} The translated string
  */
  pgettext (context, msgid) {
    return this.getTranslation(msgid, 1, context)
  }

  /**
  * Returns a string of the translation of either the singular or plural,
  * based on the number.
  * Also makes the string discoverable by xgettext.
  *
  * @param {String} msgid - The translation key
  * @param {String} plural - The plural form of the translation key
  * @param {Number} n - The number to switch between singular and plural
  *
  * @return {String} The translated string
  */
  ngettext (msgid, plural, n) {
    return this.getTranslation(msgid, n, null, plural)
  }

  /**
  * Returns a string of the translation of either the singular or plural,
  * based on the number, for the given context.
  * Also makes the string discoverable by xgettext.
  *
  * @param {String} context - The context of the string to translate
  * @param {String} msgid - The translation key
  * @param {String} plural - The plural form of the translation key
  * @param {Number} n - The number to switch between singular and plural
  *
  * @return {String} The translated string
  */
  npgettext (context, msgid, plural, n) {
    return this.getTranslation(msgid, n, context, plural)
  }

  /**
   * Evaluate a piece of template string containing %{ } placeholders.
   * E.g.: 'Hi %{ user.name }' => 'Hi Bob'
   *
   * This is a vm.$interpolate alternative for Vue 2.
   * https://vuejs.org/v2/guide/migration.html#vm-interpolate-removed
   *
   * @param {String} msgid - The translation key containing %{ } placeholders
   * @param {Object} context - An object whose elements are put in their corresponding placeholders
   *
   * @return {String} The interpolated string
   */
  interpolate (msgid, context = {}) {
    if (!this._vm.silent && MUSTACHE_SYNTAX_RE.test(msgid)) {
      console.warn(`Mustache syntax cannot be used with vue-gettext. Please use "%{}" instead of "{{}}" in: ${msgid}`)
    }

    let result = msgid.replace(INTERPOLATION_RE, (match, token) => {

      const expression = token.trim()
      let evaluated

      // Avoid eval() by splitting `expression` and looping through its different properties if any, see #55.
      function getProps (obj, expression) {
        const arr = expression.split(EVALUATION_RE).filter(x => x)
        while (arr.length) {
          obj = obj[arr.shift()]
        }
        return obj
      }

      function evalInContext (expression) {
        try {
          evaluated = getProps(this, expression)
        } catch (e) {
          // Ignore errors, because this function may be called recursively later.
        }
        if (evaluated === undefined) {
          if (this.$parent) {
            // Recursively climb the $parent chain to allow evaluation inside nested components, see #23 and #24.
            return evalInContext.call(this.$parent, expression)
          } else {
            console.warn(`Cannot evaluate expression: ${expression}`)
            evaluated = expression
          }
        }
        return evaluated
      }

      return evalInContext.call(context, expression)

    })

    return result

  }
}

VueGettext.install = install

// Store this values as function attributes for easy access elsewhere to bypass a Rollup
// weak point with `export`:
// https://github.com/rollup/rollup/blob/fca14d/src/utils/getExportMode.js#L27
VueGettext.INTERPOLATION_RE = INTERPOLATION_RE
VueGettext.INTERPOLATION_PREFIX = '%{'
